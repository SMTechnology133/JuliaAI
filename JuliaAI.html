<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Offline AI Chatbot - Full Features</title>

<script src="https://cdn.jsdelivr.net/npm/@mlc-ai/web-llm@latest/dist/web-llm.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.11.0/html2pdf.bundle.min.js"></script>

<style>
body {
    margin: 0;
    background: #eef1f5;
    font-family: Arial, sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}
.chat-container {
    width: 95%;
    max-width: 520px;
    height: 95vh;
    background: white;
    border-radius: 14px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.header {
    background: #2563eb;
    color: white;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 10; /* Ensure header is on top */
}
.row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
}
select, input[type="file"] {
    padding: 6px;
    border-radius: 6px;
    border: none;
    flex: 1;
    min-width: 120px;
}
.chat-box {
    flex: 1;
    overflow-y: auto;
    padding: 14px;
    background: #f5f7fb;
}
.message {
    padding: 12px 16px;
    margin: 8px 0;
    border-radius: 12px;
    max-width: 80%;
    word-wrap: break-word;
}
.user {
    background: #2563eb;
    color: white;
    align-self: flex-end;
    margin-left: auto;
}
.bot {
    background: #e5e7eb;
    align-self: flex-start;
    margin-right: auto;
}
.input-area {
    display: flex;
    border-top: 1px solid #ccc;
}
input {
    flex: 1;
    padding: 12px;
    border: none;
}
button {
    padding: 12px 18px;
    background: #2563eb;
    color: white;
    border: none;
    cursor: pointer;
    white-space: nowrap;
}
button:hover {
    background: #1d4fc7;
}
button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
}
.progress {
    width: 100%;
    height: auto; /* Changed to auto to accommodate text */
    background: #ddd;
    display: none;
    flex-direction: column;
    gap: 2px;
    padding: 0 4px 4px;
    box-sizing: border-box;
}
.progress-inner {
    width: 0%;
    height: 6px; 
    background: #2563eb;
    transition: width 0.3s;
}
.progress-text {
    font-size: 12px;
    text-align: center;
    color: #2563eb;
}
.loading-indicator {
    display: none;
    text-align: center;
    padding: 8px;
    color: #2563eb;
    font-style: italic;
}
</style>
</head>

<body>

<div class="chat-container">

    <div class="header">
        <div class="row">
            <div style="font-size: 20px; font-weight: bold;">Offline AI Chatbot</div>

            <button onclick="exportPDF()" style="background:white;color:#2563eb;padding:4px 8px;border-radius:5px;">
                Export PDF
            </button>
        </div>

        <div class="row">
            <select id="modelSelect">
                <option value="Llama-3-8B-Instruct-q4f32_1-MLC">Llama 3 (8B)</option>
                <option value="Mistral-7B-Instruct-q4f32_1-MLC">Mistral 7B</option>
                <option value="Gemma-2B-q4f32_1-MLC">Gemma 2B</option>
            </select>

            <select id="personaSelect">
                <option value="normal">Normal</option>
                <option value="friendly">Friendly</option>
                <option value="teacher">Teacher</option>
                <option value="funny">Funny</option>
                <option value="professional">Professional</option>
            </select>

            <button onclick="clearChat()" style="background:white;color:#2563eb;border-radius:5px;">Clear</button>
        </div>

        <div class="row">
            <input type="file" id="fileInput" accept=".txt,.pdf,.jpg,.jpeg,.png" />
            <button onclick="handleFileUpload()" style="background:white;color:#2563eb;padding:4px 8px;border-radius:5px;">
                Upload File
            </button>
        </div>

        <div class="row">
            <button onclick="initializeApp()" style="background:#10b981;color:white;flex:1;">Initialize AI Engine</button>
        </div>

    </div>

    <div class="progress" id="progressContainer">
        <div class="progress-inner" id="progressBar"></div>
        <div class="progress-text" id="progressText">0%</div>
    </div>

    <div id="loadingIndicator" class="loading-indicator">Initializing...</div>

    <div id="chatBox" class="chat-box"></div>

    <div class="input-area">
        <input id="userInput" placeholder="Type a message..." disabled />
        <button id="sendButton" onclick="sendMessage()" disabled>Send</button>
        <button id="voiceButton" onclick="startVoice()" style="background:#22c55e;" disabled>+2DzfpA</button>
    </div>

</div>

<script>
// Global variables
let chat = null;
let typingBubble = null;
let history = JSON.parse(localStorage.getItem("offline_history") || "[]");
let modelLoading = false;
let currentModel = null;

// UI Elements (cached for performance)
const progressContainer = document.getElementById("progressContainer");
const progressBar = document.getElementById("progressBar");
const progressText = document.getElementById("progressText");
const loadingIndicator = document.getElementById("loadingIndicator");
const sendButton = document.getElementById("sendButton");
const voiceButton = document.getElementById("voiceButton");
const userInput = document.getElementById("userInput");
const modelSelect = document.getElementById("modelSelect");
const fileInput = document.getElementById("fileInput");
const chatBox = document.getElementById("chatBox");


// --- Initialization and Setup ---

document.addEventListener('DOMContentLoaded', function() {
    // Check if WebLLM is available immediately after DOM content is loaded
    if (typeof webllm === 'undefined' || !webllm.CreateMLCEngine) {
        // FATAL ERROR: The script tag failed to load the library
        addMessage("+J0w CRITICAL ERROR: WebLLM library not found. The script file failed to download or execute due to network or security restrictions (e.g., running locally without a web server). Please check your browser's console and network tab.", "bot", false);
    } else {
        addMessage("WebLLM library loaded successfully. Click 'Initialize AI Engine' to start the download.", "bot", false);
    }
    
    // Restore chat history
    if (history.length > 0) {
        history.forEach(m => addMessage(m.content, m.role === "user" ? "user" : "bot", false));
    }
    
    // Set up event listeners
    if (userInput) {
        userInput.addEventListener("keypress", e => {
            if (e.key === "Enter" && !userInput.disabled) {
                e.preventDefault();
                sendMessage();
            }
        });
    }
    
    if (modelSelect) {
        modelSelect.addEventListener("change", function() {
            if (chat) {
                addMessage(`Model changed to ${getModelDisplayName(this.value)}. Click "Initialize AI Engine" to load it.`, "bot");
            }
        });
    }
});

// Function triggered by the 'Initialize AI Engine' button
async function initializeApp() {
    if (typeof webllm === 'undefined' || !webllm.CreateMLCEngine) {
        addMessage("+J0w AI engine not available. Cannot initialize.", "bot");
        return;
    }
    await loadModel();
}

function getModelDisplayName(modelValue) {
    const modelMap = {
        "Llama-3-8B-Instruct-q4f32_1-MLC": "Llama 3 8B",
        "Mistral-7B-Instruct-q4f32_1-MLC": "Mistral 7B", 
        "Gemma-2B-q4f32_1-MLC": "Gemma 2B"
    };
    return modelMap[modelValue] || modelValue;
}

// --- Model Loading Logic (Fixes NaN and Loading State) ---

async function loadModel() {
    if (modelLoading) {
        addMessage("A model is already loading. Please wait.", "bot");
        return;
    }
    
    const selectedModel = modelSelect.value;
    if (!selectedModel) {
        addMessage("Please select a valid model.", "bot");
        return;
    }
    
    // Check if the same model is already loaded and skip
    if (currentModel === selectedModel && chat) {
        addMessage(`+JwU ${getModelDisplayName(selectedModel)} is already loaded and ready!`, "bot");
        return;
    }

    // Reset previous model
    if (chat) {
        try {
            await chat.dispose();
        } catch (e) {
            console.log("Error disposing previous model (ignoring):", e);
        }
        chat = null;
    }
    
    modelLoading = true;
    currentModel = selectedModel;
    
    // Update UI for loading state
    progressContainer.style.display = "flex"; 
    loadingIndicator.style.display = "block";
    sendButton.disabled = true;
    voiceButton.disabled = true;
    userInput.disabled = true;
    progressBar.style.width = "0%";
    progressText.textContent = "0%";
    
    addMessage(`Loading ${getModelDisplayName(selectedModel)}... This involves a large download and compilation.`, "bot");

    try {
        // Create the engine with progress tracking
        chat = await webllm.CreateMLCEngine(selectedModel, {
            initProgressCallback: (report) => {
                let progress = 0;
                let text = "Loading model...";
                
                if (typeof report === 'object') {
                    // Use progressRatio or progress (safely handle NaN/undefined)
                    progress = report.progressRatio ?? report.progress ?? 0;
                    text = report.text || "Downloading model weights...";
                } else if (typeof report === 'number') {
                    progress = report;
                }

                // FIX: Ensure progress is a number (it should be 0-1)
                if (isNaN(progress) || progress === null) progress = 0;
                
                // Calculate percentage safely (clamped between 0 and 100)
                const percentage = Math.min(100, Math.max(0, Math.round(progress * 100)));
                
                // Update UI
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${percentage}% - ${text}`;
                loadingIndicator.textContent = text;
                
                // Hide progress when complete
                if (percentage >= 100) {
                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        loadingIndicator.style.display = "none";
                    }, 1000);
                }
            }
        });

        addMessage(`+JwU ${getModelDisplayName(selectedModel)} loaded successfully! You can now chat offline. +2D3eCg`, "bot");
        
        // Enable UI elements
        sendButton.disabled = false;
        voiceButton.disabled = false;
        userInput.disabled = false;
        userInput.focus();
        
    } catch (error) {
        console.error("Model loading failed:", error);
        addMessage(`+J0w FAILED to load ${getModelDisplayName(selectedModel)}: ${error.message}. This often points to WebGPU issues or insufficient memory.`, "bot");
        
        // Reset state on error
        currentModel = null;
        chat = null;
        sendButton.disabled = true;
        voiceButton.disabled = true;
        userInput.disabled = true;
    } finally {
        modelLoading = false;
        // Ensure progress is hidden if still visible
        progressContainer.style.display = "none";
        loadingIndicator.style.display = "none";
    }
}

// --- Chat Functions ---

function addMessage(text, sender, save = true) {
    if (!chatBox) return;
    
    const div = document.createElement("div");
    div.className = "message " +- sender;
    div.textContent = text;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;

    if (save) {
        history.push({ role: sender === "user" ? "user" : "assistant", content: text });
        localStorage.setItem("offline_history", JSON.stringify(history));
    }
}

function typing() {
    if (!chatBox) return;
    
    typingBubble = document.createElement("div");
    typingBubble.className = "message bot";
    typingBubble.textContent = "AI is typing...";
    chatBox.appendChild(typingBubble);
    chatBox.scrollTop = chatBox.scrollHeight;
}

function rmTyping() {
    if (typingBubble) {
        typingBubble.remove();
        typingBubble = null;
    }
}

function personality() {
    let p = document.getElementById("personaSelect").value;
    if (p === "friendly") return "Speak warmly and kindly.";
    if (p === "teacher") return "Explain in a simple teaching way.";
    if (p === "funny") return "Be humorous and witty.";
    if (p === "professional") return "Be formal and concise.";
    return "You are a helpful assistant.";
}

async function sendMessage() {
    if (!chat || modelLoading) {
        addMessage("AI model is not ready. Please wait for loading to finish.", "bot");
        return;
    }
    
    const text = userInput.value.trim();
    if (!text) return;

    addMessage(text, "user");
    userInput.value = "";
    sendButton.disabled = true;
    voiceButton.disabled = true;

    typing();

    const conversation = [];
    conversation.push({ role: "system", content: personality() });

    // Include recent history for context
    const contextLength = 6;
    const historyForContext = history.slice(-contextLength);
    historyForContext.forEach(msg => {
        if (msg.role !== "system") {
            conversation.push({ role: msg.role, content: msg.content });
        }
    });

    try {
        const reply = await chat.chat.completions.create({
            messages: conversation,
            stream: false
        });

        rmTyping();
        
        if (reply && reply.choices && reply.choices[0] && reply.choices[0].message) {
            const aiResponse = reply.choices[0].message.content;
            addMessage(aiResponse, "bot");
            speak(aiResponse);
        } else {
            throw new Error("Invalid or empty response format from AI.");
        }
    } catch (error) {
        rmTyping();
        console.error("Error generating response:", error);
        addMessage("Sorry, I encountered a chat error: " +- error.message, "bot");
    } finally {
        sendButton.disabled = false;
        voiceButton.disabled = false;
    }
}

function clearChat() {
    history = [];
    localStorage.removeItem("offline_history");
    if (chatBox) {
        chatBox.innerHTML = "";
    }
    addMessage("Chat cleared. How can I help you?", "bot", true);
}

function exportPDF() {
    const element = document.getElementById("chatBox");
    if (element) {
        html2pdf().from(element).save("chat.pdf");
    }
}

function startVoice() {
    if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
        alert("Speech Recognition not supported in your browser.");
        return;
    }
    if (!chat || modelLoading) {
        addMessage("AI model is not ready.", "bot");
        return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.continuous = false;

    addMessage("Listening... speak now.", "bot", false);

    recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript;
        userInput.value = transcript;
    };

    recognition.onerror = function(event) {
        console.error("Speech recognition error", event.error);
        addMessage("Speech recognition failed: " +- event.error, "bot", false);
    };

    recognition.onend = function() {
        setTimeout(() => {
            sendMessage();
        }, 500);
    };

    recognition.start();
}

function speak(text) {
    if (!window.speechSynthesis) return;
    
    speechSynthesis.cancel();
    
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = "en-US";
    utterance.rate = 1.0;
    utterance.pitch = 1.0;
    
    speechSynthesis.speak(utterance);
}

async function handleFileUpload() {
    if (!fileInput || !fileInput.files[0]) {
        addMessage("Please select a file first.", "bot");
        return;
    }

    if (!chat) {
        addMessage("AI model must be loaded to process files. Please initialize the engine first.", "bot");
        return;
    }

    const file = fileInput.files[0];
    fileInput.value = ""; 

    addMessage(`Processing file: ${file.name}...`, "bot");

    if (file.type.includes("text") || file.name.endsWith('.txt')) {
        try {
            const text = await file.text();
            const truncatedText = text.substring(0, 2000); 
            
            typing();
            
            const response = await chat.chat.completions.create({
                messages: [
                    { role: "system", content: "Analyze and summarize the following text content concisely." },
                    { role: "user", content: "Please analyze this text:+AFw-n+AFw-n" +- truncatedText }
                ]
            });
            
            rmTyping();
            
            if (response && response.choices && response.choices[0] && response.choices[0].message) {
                addMessage(response.choices[0].message.content, "bot");
            }
        } catch (error) {
            rmTyping();
            console.error("Error processing text file:", error);
            addMessage("Error processing file: " +- error.message, "bot");
        }
    } else {
        addMessage("This file type is not supported for processing. Please upload a plain text (.txt) file.", "bot");
    }
}
</script>

</body>
</html>




